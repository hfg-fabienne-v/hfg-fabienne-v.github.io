{"ast":null,"code":"import _slicedToArray from \"/Users/fabienne/studium/praxissemester/portfolio/fabienne.vatter/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport \"regenerator-runtime/runtime.js\";\nimport \"core-js/modules/es.object.freeze.js\";\nimport \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.number.constructor.js\";\nimport \"core-js/modules/es.number.is-nan.js\";\nimport { nextTick } from 'vue';\nimport throttle from 'lodash/throttle';\nimport { entries } from '../utils/util';\nimport { getScrollContainer, getOffsetTopDistance } from '../utils/dom';\nimport throwError from '../utils/error';\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\n\nvar EMPTY_OBJ = process.env.NODE_ENV !== 'production' ? Object.freeze({}) : {};\nvar EMPTY_ARR = process.env.NODE_ENV !== 'production' ? Object.freeze([]) : [];\n\nvar isFunction = function isFunction(val) {\n  return typeof val === 'function';\n};\n\nvar __async = function __async(__this, __arguments, generator) {\n  return new Promise(function (resolve, reject) {\n    var fulfilled = function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var rejected = function rejected(value) {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    var step = function step(x) {\n      return x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    };\n\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\nvar SCOPE = \"ElInfiniteScroll\";\nvar CHECK_INTERVAL = 50;\nvar DEFAULT_DELAY = 200;\nvar DEFAULT_DISTANCE = 0;\nvar attributes = {\n  delay: {\n    type: Number,\n    default: DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    default: DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  immediate: {\n    type: Boolean,\n    default: true\n  }\n};\n\nvar getScrollOptions = function getScrollOptions(el, instance) {\n  return entries(attributes).reduce(function (acm, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        option = _ref2[1];\n\n    var _a, _b;\n\n    var type = option.type,\n        defaultValue = option.default;\n    var attrVal = el.getAttribute(\"infinite-scroll-\".concat(name));\n    var value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\n\nvar destroyObserver = function destroyObserver(el) {\n  var observer = el[SCOPE].observer;\n\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\n\nvar handleScroll = function handleScroll(el, cb) {\n  var _el$SCOPE = el[SCOPE],\n      container = _el$SCOPE.container,\n      containerEl = _el$SCOPE.containerEl,\n      instance = _el$SCOPE.instance,\n      observer = _el$SCOPE.observer,\n      lastScrollTop = _el$SCOPE.lastScrollTop;\n\n  var _getScrollOptions = getScrollOptions(el, instance),\n      disabled = _getScrollOptions.disabled,\n      distance = _getScrollOptions.distance;\n\n  var clientHeight = containerEl.clientHeight,\n      scrollHeight = containerEl.scrollHeight,\n      scrollTop = containerEl.scrollTop;\n  var delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0) return;\n  var shouldTrigger = false;\n\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    var clientTop = el.clientTop,\n        height = el.scrollHeight;\n    var offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\n\nfunction checkFull(el, cb) {\n  var _el$SCOPE2 = el[SCOPE],\n      containerEl = _el$SCOPE2.containerEl,\n      instance = _el$SCOPE2.instance;\n\n  var _getScrollOptions2 = getScrollOptions(el, instance),\n      disabled = _getScrollOptions2.disabled;\n\n  if (disabled) return;\n\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\n\nvar InfiniteScroll = {\n  mounted: function mounted(el, binding) {\n    return __async(this, null, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var instance, cb, _getScrollOptions3, delay, immediate, container, containerEl, onScroll, observer;\n\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              instance = binding.instance, cb = binding.value;\n\n              if (!isFunction(cb)) {\n                throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n              }\n\n              _context.next = 4;\n              return nextTick();\n\n            case 4:\n              _getScrollOptions3 = getScrollOptions(el, instance), delay = _getScrollOptions3.delay, immediate = _getScrollOptions3.immediate;\n              container = getScrollContainer(el, true);\n              containerEl = container === window ? document.documentElement : container;\n              onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n\n              if (container) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 10:\n              el[SCOPE] = {\n                instance: instance,\n                container: container,\n                containerEl: containerEl,\n                delay: delay,\n                cb: cb,\n                onScroll: onScroll,\n                lastScrollTop: containerEl.scrollTop\n              };\n\n              if (immediate) {\n                observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n                el[SCOPE].observer = observer;\n                observer.observe(el, {\n                  childList: true,\n                  subtree: true\n                });\n                checkFull(el, cb);\n              }\n\n              container.addEventListener(\"scroll\", onScroll);\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n  },\n  unmounted: function unmounted(el) {\n    var _el$SCOPE3 = el[SCOPE],\n        container = _el$SCOPE3.container,\n        onScroll = _el$SCOPE3.onScroll;\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  }\n};\nvar _InfiniteScroll = InfiniteScroll;\n\n_InfiniteScroll.install = function (app) {\n  app.directive(\"InfiniteScroll\", _InfiniteScroll);\n};\n\nexport default _InfiniteScroll;","map":{"version":3,"sources":["/Users/fabienne/studium/praxissemester/portfolio/fabienne.vatter/node_modules/element-plus/es/el-infinite-scroll/index.js"],"names":["nextTick","throttle","entries","getScrollContainer","getOffsetTopDistance","throwError","EMPTY_OBJ","process","env","NODE_ENV","Object","freeze","EMPTY_ARR","isFunction","val","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","throw","x","done","then","apply","SCOPE","CHECK_INTERVAL","DEFAULT_DELAY","DEFAULT_DISTANCE","attributes","delay","type","Number","default","distance","disabled","Boolean","immediate","getScrollOptions","el","instance","reduce","acm","name","option","_a","_b","defaultValue","attrVal","getAttribute","isNaN","destroyObserver","observer","disconnect","handleScroll","cb","container","containerEl","lastScrollTop","clientHeight","scrollHeight","scrollTop","delta","shouldTrigger","clientTop","height","offsetTop","call","checkFull","InfiniteScroll","mounted","binding","window","document","documentElement","onScroll","bind","MutationObserver","observe","childList","subtree","addEventListener","unmounted","removeEventListener","_InfiniteScroll","install","app","directive"],"mappings":"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","sourcesContent":["import { nextTick } from 'vue';\nimport throttle from 'lodash/throttle';\nimport { entries } from '../utils/util';\nimport { getScrollContainer, getOffsetTopDistance } from '../utils/dom';\nimport throwError from '../utils/error';\n\n/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst isFunction = (val) => typeof val === 'function';\n\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nconst SCOPE = \"ElInfiniteScroll\";\nconst CHECK_INTERVAL = 50;\nconst DEFAULT_DELAY = 200;\nconst DEFAULT_DISTANCE = 0;\nconst attributes = {\n  delay: {\n    type: Number,\n    default: DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    default: DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  },\n  immediate: {\n    type: Boolean,\n    default: true\n  }\n};\nconst getScrollOptions = (el, instance) => {\n  return entries(attributes).reduce((acm, [name, option]) => {\n    var _a, _b;\n    const { type, default: defaultValue } = option;\n    const attrVal = el.getAttribute(`infinite-scroll-${name}`);\n    let value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\nconst destroyObserver = (el) => {\n  const { observer } = el[SCOPE];\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\nconst handleScroll = (el, cb) => {\n  const {\n    container,\n    containerEl,\n    instance,\n    observer,\n    lastScrollTop\n  } = el[SCOPE];\n  const { disabled, distance } = getScrollOptions(el, instance);\n  const { clientHeight, scrollHeight, scrollTop } = containerEl;\n  const delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0)\n    return;\n  let shouldTrigger = false;\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    const { clientTop, scrollHeight: height } = el;\n    const offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\nfunction checkFull(el, cb) {\n  const { containerEl, instance } = el[SCOPE];\n  const { disabled } = getScrollOptions(el, instance);\n  if (disabled)\n    return;\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\nconst InfiniteScroll = {\n  mounted(el, binding) {\n    return __async(this, null, function* () {\n      const { instance, value: cb } = binding;\n      if (!isFunction(cb)) {\n        throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n      }\n      yield nextTick();\n      const { delay, immediate } = getScrollOptions(el, instance);\n      const container = getScrollContainer(el, true);\n      const containerEl = container === window ? document.documentElement : container;\n      const onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n      if (!container)\n        return;\n      el[SCOPE] = {\n        instance,\n        container,\n        containerEl,\n        delay,\n        cb,\n        onScroll,\n        lastScrollTop: containerEl.scrollTop\n      };\n      if (immediate) {\n        const observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n        el[SCOPE].observer = observer;\n        observer.observe(el, { childList: true, subtree: true });\n        checkFull(el, cb);\n      }\n      container.addEventListener(\"scroll\", onScroll);\n    });\n  },\n  unmounted(el) {\n    const { container, onScroll } = el[SCOPE];\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  }\n};\n\nconst _InfiniteScroll = InfiniteScroll;\n_InfiniteScroll.install = (app) => {\n  app.directive(\"InfiniteScroll\", _InfiniteScroll);\n};\n\nexport default _InfiniteScroll;\n"]},"metadata":{},"sourceType":"module"}